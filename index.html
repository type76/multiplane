<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>multiplane z</title>

<style>
body { margin: 0; overflow: hidden; background: #222;
font-family: monospace;}

canvas { width: 100%; height: 100%; position:absolute;}
#speedo {position: absolute; top: 0px; left: 10px; z-index: 2;
color: #fff;}
</style>

</head>
<body>
	<p id="speedo">0</p>
	<canvas width="512" height="512" style="width: 512px; height: 512px;"></canvas>

	<script src="js/three.min.js"></script>
	<script src="js/orbitcontrols.min.js"></script>


	<script>

// lane 3 = -6
// lane 2 = -2
// lane 1 = 2

// handheld screen
var lcdwidth = 7;
var lcdheight = 5;
// handheld dimensions
var gamewidth = 600;
var gameheight = 300;

var xval = 0; // speed
var topspeed = 10; //change for acceleration
var slowdown = false;
var started = false;

var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(
	35, // 35mm film camera
	window.innerWidth / window.innerHeight,
	1, // min render
	100 // max render
	);

// camera settings

camera.position.set(0,0,30);

// renderer
var renderer = new THREE.WebGLRenderer({ alpha: true });
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFShadowMap;
document.body.appendChild( renderer.domElement );

// controls
var controls = new THREE.OrbitControls( camera, renderer.domElement );
controls.enablePan = false;
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.rotateSpeed = 0.02;
controls.maxDistance = 40;
controls.minDistance = 20;

// whole scene
maingroup = new THREE.Group();
scene.add( maingroup );

// hero group
hero = new THREE.Group();
maingroup.add( hero );

// moving invisible group
cursor = new THREE.Group();
maingroup.add(cursor);

// the mothership
mothership = new THREE.Group();
maingroup.add(mothership);

// LCD world
world = new THREE.Group();
maingroup.add(world);

mothership.position.set(-4,0,0);


// planes
var asteroid_layers = [];

// lights                
var light = new THREE.AmbientLight( 0xffffff , 0.5);
maingroup.add( light );

var light = new THREE.PointLight( 0xffffff, 1, 40 );
light.position.set( 10, 10, 10 );
scene.add( light );

//spot light
var splight = new THREE.SpotLight( 0xffffff, 0.1 );
splight.position.set( 0, 30, 0 );
splight.castShadow = true;
splight.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 100 ) );
splight.shadow.mapSize.width = 512;
splight.shadow.mapSize.height = 512;
light.shadow.camera.near = 0.5;
light.shadow.camera.far = 50;

splight.name = 'splight';
scene.add( splight );


// Clipping plane (mask)
var clip_shape = new THREE.Shape();
clip_shape.moveTo( -gamewidth, -gameheight );
clip_shape.lineTo( gamewidth, -gameheight );
clip_shape.lineTo( gamewidth, gameheight );
clip_shape.lineTo( -gamewidth, gameheight );
clip_shape.lineTo(-gamewidth, -gameheight );
var clip_hole = new THREE.Shape();
clip_hole.moveTo( -lcdwidth, -lcdheight );
clip_hole.lineTo( lcdwidth, -lcdheight );
clip_hole.lineTo( lcdwidth, lcdheight );
clip_hole.lineTo( -lcdwidth, lcdheight);
clip_hole.lineTo( -lcdwidth, -lcdheight );
clip_shape.holes.push(clip_hole);
var clip_plane = new THREE.ShapeBufferGeometry( clip_shape );
var clip_material = new THREE.MeshBasicMaterial({
	colorWrite: false, //remove to see
});
var clip_layer = new THREE.Mesh( clip_plane, clip_material );
clip_layer.renderOrder = 1;
clip_layer.position.z = 5.2;
maingroup.add( clip_layer );



// floor texture
var geometry =  new THREE.PlaneBufferGeometry( 80, 20, 1 );
var material = new THREE.MeshLambertMaterial( {color: 0x333333, clippingPlanes: [clip_layer], transparent: true } );
var ground = new THREE.Mesh( geometry, material );
ground.receiveShadow = true;
ground.rotation.set (-Math.PI/2,0,0);
ground.position.set (0,-5.1,-5);
scene.add( ground );


//// LCD outline
var size = lcdheight*2;
var divisions = 1;
var gridHelper = new THREE.GridHelper(size, divisions, 1, 0x333333 );
gridHelper.rotation.x = Math.PI/2;
gridHelper.position.z = 5.2;
gridHelper.scale.x = 1.5;
maingroup.add(gridHelper)

// button outlines
var curve = new THREE.EllipseCurve(
  0,  0,            // ax, aY
  1, 1,           	// xRadius, yRadius
  0,  2 * Math.PI,  // aStartAngle, aEndAngle
  false,            // aClockwise
  0                 // aRotation
);

var points = curve.getPoints( 30 );
var dgeometry = new THREE.BufferGeometry().setFromPoints( points );
var dmaterial = new THREE.LineBasicMaterial( { color : 0x333333
 } );
// left button
var buttonL = new THREE.Line( dgeometry, dmaterial );
buttonL.position.set(-12, -4, 5.2);
maingroup.add(buttonL);
// right button
var buttonR = buttonL.clone();
buttonR.position.set (12,-4, 5.2);
maingroup.add(buttonR);

// hero / mothership object
// let bgeometry = new THREE.BoxGeometry( 1, 1, 1 );
// let mmaterial = new THREE.MeshBasicMaterial( { 
// 	color: 0xff0000,
// 	clippingPlanes: [clip_layer],
// 	transparent: true
//  } );
// let cubicbody = new THREE.Mesh( bgeometry, mmaterial );
// cubicbody.position.set(0,0,2);
// cubicbody.renderOrder = 2;
// mothership.add( cubicbody );


// ship
var shiptex = new THREE.TextureLoader().load( 'assets/rocket.png' );
shiptex.magFilter = THREE.NearestFilter;
shiptex.minFilter = THREE.LinearMipMapLinearFilter;
var shpgeometry = new THREE.PlaneBufferGeometry( 2, 2, 1 );
var shpmaterial = new THREE.MeshBasicMaterial( {
	color: 0xffffff, 
	map:shiptex,
	clippingPlanes: [clip_layer]
	,transparent: true
	// opacity:1
} );
var ship = new THREE.Mesh( shpgeometry, shpmaterial );
ship.position.z = 2.01;
ship.position.y = -2;
ship.renderOrder = 2;

mothership.add( ship );

// shadow
var shdwgeometry = new THREE.PlaneBufferGeometry( 2, 2, 1 );
var shdwmaterial = new THREE.MeshBasicMaterial( {
	color: 0x000000, 
	map:shiptex,
	clippingPlanes: [clip_layer]
	,transparent: true,
	opacity:0.2
} );
var shdw = new THREE.Mesh( shdwgeometry, shdwmaterial );
shdw.position.z = 0.2;
// shdw.scale.y = 2;
shdw.position.y = -2.9;
shdw.renderOrder = 2;
shdw.rotation.x = -Math.PI/2;
// shdw.rotation.z = Math.PI;
ship.add( shdw );



// handheld
// var loader = new THREE.BufferGeometryLoader();
// loader.load(
//     'handheld.json',
//     function ( geometry ) {
//         var material = new THREE.MeshLambertMaterial( { 
// 			color:0x333333
//         } );
//         var object = new THREE.Mesh( geometry, material );
//         object.scale.set( 10, 10, 10 );
//         object.position.set( 0, 0, 5.5 );
// 		object.rotation.set(0,Math.PI/2,0);
//         // maingroup.add( object );
//     },
//     function ( xhr ) {},
//     function ( xhr ) {console.log( 'An error happened' );}
//     );

// lines
var geometry = new THREE.Geometry();
geometry.vertices.push(new THREE.Vector3( -30, -5, 2) );
geometry.vertices.push(new THREE.Vector3( 30, -5, 2) );
var material = new THREE.LineBasicMaterial( { 
	color: 0x333333
	, clippingPlanes: [clip_layer]
	,transparent: true } );
var line1 = new THREE.Line( geometry, material );
maingroup.add( line1 );

var line2 = new THREE.Line( geometry, material );
line2.position.set (0,0,-4);
maingroup.add(line2);

var line3 = new THREE.Line( geometry, material );
line3.position.set (0,0,-8);
maingroup.add(line3);


// make multiplane layers
addLayer("assets/asteroid.png", -6, 0.1, 1, true);
addLayer("assets/asteroid.png", -2, 0.1, 1, true);
addLayer("assets/asteroid.png", 2, 0.1, 1, true);


// add multiplane layers			
function addLayer(layer_name, position, scale, opacity, animation) {
	var geometry = new THREE.PlaneGeometry (20, 20);
	var texture = new THREE.TextureLoader().load( layer_name, function() {});
// dont anti alias texture
	texture.magFilter = THREE.NearestFilter;
	texture.minFilter = THREE.LinearMipMapLinearFilter;

	var material = new THREE.MeshBasicMaterial({
		map: texture,
		transparent: true,
		opacity: opacity,
		clippingPlanes: [clip_layer]
		// ,side: THREE.DoubleSide
	})
	var layer = new THREE.Mesh( geometry, material );
	layer.material.map.wrapS = THREE.RepeatWrapping;
	layer.position.z = position;
	layer.position.y = -2;
	layer.position.x = (Math.random()*10)+10;

	layer.scale.x = scale;
	layer.scale.y = scale;
	layer.scale.z = scale;
	layer.renderOrder = 2;
	asteroid_layers.push(layer);
	world.add( layer );
	//

var geometry = new THREE.SphereBufferGeometry( 9, 8, 8 );
var material = new THREE.MeshBasicMaterial( {
	color: 0xffff00, transparent:true,
		clippingPlanes: [clip_layer]
	} );
var sphere = new THREE.Mesh( geometry, material );
sphere.castShadow = true;
layer.add( sphere );
sphere.visibile = false;
sphere.material.colorWrite = false;
sphere.material.depthWrite = false;
}


window.addEventListener('mousedown', function(event) {
	controls.enableDamping = true;
});
window.addEventListener('touchstart', function(event) {
	controls.enableDamping = true;
});


window.addEventListener('resize', function() {
	resizeCanvas();			
});

function resizeCanvas() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );
}



function animate() {
	requestAnimationFrame( animate );
	controls.update();
	renderer.render( scene, camera );
	bgmove();
	heromove();
}


animate();


//keys
//esc
document.onkeydown = function(evt) {
	evt = evt || window.event;
// console.log(evt)

if (evt.keyCode == 37) {// left
	evt.preventDefault();
	if (started) {notPressingDown()}  
}

if (evt.keyCode == 39) {// right
	evt.preventDefault();
	pressingDown()  
}

if (evt.keyCode == 38) {// up
	evt.preventDefault();
	if (hero.position.z>-8) {hero.position.z=hero.position.z-4;}
}

if (evt.keyCode == 40) {// down
	evt.preventDefault();
	if (hero.position.z<0) {hero.position.z=hero.position.z+4;}
}

};


// pedal down
function pressingDown(e) {
	slowdown = false;
	started = true;
	timerID = cancelAnimationFrame(slowtimer);
	timerID = requestAnimationFrame(timer);
	if (e) {e.preventDefault();}
}

// pedal up
function notPressingDown(e) {
	slowdown = true;
	timerID = cancelAnimationFrame(timerID);
	timerID = requestAnimationFrame(slowtimer);
	if (e) {e.preventDefault();}
}

// decelerate
function slowtimer() {
	if (xval<0) {return}
	xval = xval - 0.1;
	if (xval<0.1) {
		cancelAnimationFrame(slowtimer); return;} else {
			requestAnimationFrame(slowtimer);
		}
	}


// accelerate
	function timer() { 
		if (xval < topspeed || slowdown == true) {
			timerID = requestAnimationFrame(timer);
			xval = xval + 0.1;
		}
	}

// move background
function bgmove() {
if (xval<1) {return}
for ( var i = 0; i < asteroid_layers.length; i ++ ) { 
	asteroid_layers[i].position.x -= xval/100;
  if (asteroid_layers[i].position.x < -11) {
    // var rnd = Math.random()/10;
    asteroid_layers[i].position.x = (Math.random()*10)+10;
    // asteroid_layers[i].scale.set(rnd, rnd, rnd);
    // console.log(asteroid_layers[i])
	
  }
}
	// make this more random
	asteroid_layers[0].rotation.z += Math.random()/20;
	asteroid_layers[1].rotation.z -= Math.random()/20;
	asteroid_layers[2].rotation.z += Math.random()/35;

// // show speed on screen
document.getElementById('speedo').innerHTML = Math.round(xval*10);

}

// move mothership
function heromove() {
// position
mothership.position.z += (hero.position.z - cursor.position.z)*0.1;
// cursor
cursor.position.x = mothership.position.x;
cursor.position.z = mothership.position.z;
}// end hero move

</script>
</body>
</html>